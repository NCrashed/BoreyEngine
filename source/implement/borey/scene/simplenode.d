// Copyright (—Å) 2013 Gushcha Anton <ncrashed@gmail.com>
/*
* This file is part of Borey Engine.
*
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
// This file is written in D programming language
/**
*   Simple realization of ISceneNode.
*/
module borey.scene.simplenode;
@safe:

import borey.log;
import borey.scene.node;
import borey.util.common;
import borey.util.vector;
import borey.util.quaternion;
import std.algorithm;
import std.container;
import std.range;

/**
*   Basic scene node, implements minimum functionality.
*/
synchronized class SimpleSceneNode : ISceneNode
{
    this(string name, shared ISceneNode parent, shared ILogger logger) @trusted
    {
        mLogger = logger;
        mName = name;
        mParent = parent;
        cast()mChildren = DList!(shared ISceneNode)();
    }

    /**
    *   Returns scene node name to accessing by name.
    */
    string name() const @property
    {
        return mName;
    }

    /**
    *   Returns node parent, or null to root scene node 
    *   (special case is detached scene node which won't be drawed).
    */
    shared(ISceneNode) parent() @property
    {
        return mParent;
    }

    /**
    *   Setting node parent. 
    *
    *   See_Also: detachChild, attachChild for user code.
    */
    void parent(shared ISceneNode node) @property
    {
        mParent = node;
    }

    /**
    *   Returns range of attached children.
    */
    InputRange!(shared ISceneNode) children() @property @trusted
    {
        return (cast()mChildren)[].inputRangeObject();
    }

    /**
    *   Performing search of scene node by name, if recurse
    *   parameter is true, search will be recursive up to
    *   leafs of scene tree.
    *
    *   Returns: Range of finded nodes.
    */
    InputRange!(shared ISceneNode) find(string name, bool recurse = true) @trusted
    {
        if((cast()mChildren).empty)
        {
            return inputRangeObject(cast(shared(ISceneNode)[])[]);
        }

        if(!recurse)
        {
            return filter!(a => a.name == name)((cast()mChildren)[]).inputRangeObject();
        } 
        else
        {   
            DList!(shared ISceneNode) temp;
            foreach(ref child; cast()mChildren)
            {
                temp.insertBack(child.find(name));
            }
            return chain((cast()mChildren)[].filter!(a => a.name == name), temp[]).inputRangeObject();

            // Workaround, flatten problems with empty ranges
            //return chain(cast()mChildren[].filter!(a => a.name == name),
            //    flatten(cast()mChildren[].map!(a => a.find(name))) ).inputRangeObject();
        }
    }

    /**
    *   Creates child node with name. Setups default position and rotation.
    */
    shared(ISceneNode) createChild(string name, vector3df pos = vector3df.ZERO, Quaternion rot = Quaternion.UNIT) @trusted
    {
        auto node = new shared SimpleSceneNode(name, this, mLogger);
        node.position = pos;
        node.rotation = rot;
        (cast()mChildren).insertBack(node);
        return node;
    }

    /**
    *   Detaches scene node from parent.
    *   
    *   Note: to make node invisible, use visble property.
    *   Note: If node is not attached, does nothing.
    */
    void detachChild(shared ISceneNode node) @trusted
    {
        auto res = std.algorithm.find((cast()mChildren)[], node);
        if(res.empty) return;

        node.parent = null;
        (cast()mChildren).remove(res);
    }

    /**
    *   Attaches child scene node to this node.
    *
    *   Note: to make node invisible, use visble property.
    *   Note: if node already attached, does nothing.
    */
    void attachChild(shared ISceneNode node) @trusted
    {
        auto res = std.algorithm.find((cast()mChildren)[], node);
        if(!res.empty) return;

        node.parent = this;
        (cast()mChildren).insertFront(node);
    }

    /**
    *   If node is not visible, it won't be drawed as all it children.
    */
    bool visible() const @property
    {
        return mVisible;
    }

    /**
    *   If node is not visible, it won't be drawed as all it children.
    */
    void visble(bool value) @property
    {
        mVisible = value;
    }

    /**
    *   Returns node local (relative the parent) position.
    */
    vector3df position() const @property @trusted
    {
        return mPosition;
    }

    /**
    *   Sets node local position (relative the parent).
    */
    void position(vector3df val) @property @trusted
    {
        mPosition = val;
    }

    /**
    *   Return node local rotation (relative the parent).
    */
    Quaternion rotation() const @property @trusted
    {
        return mRotation;
    }

    /**
    *   Sets node local rotation (relative the parent).
    */
    void rotation(Quaternion val) @property @trusted
    {
        mRotation = val;
    }

    /**
    *   Returns absolute location (relative the root node).
    */
    vector3df absolutePosition() const @property
    {
        if(mParent is null)
            return position;
        else
            return mParent.position + position;
    }

    /**
    *   Returns absolute roatation (relative the root node).
    */
    Quaternion absoluteRotation() const @property
    {
        if(mParent is null)
            return rotation;
        else
            return mParent.rotation + rotation;
    }

    protected
    {
        string mName;
        shared ILogger mLogger;
        ISceneNode mParent;
        bool mVisible = true;
        DList!(shared ISceneNode) mChildren;
    }
    private
    {
        __gshared vector3df mPosition;
        __gshared Quaternion mRotation = Quaternion.UNIT;
    }
}

@trusted unittest
{
    import std.stdio;
    
    write("Testing simple scene node....");
    scope(failure) writeln("Failed");
    scope(success) writeln("Finished!");


    auto root = new shared SimpleSceneNode("root", null, null);
    auto aNode = root.createChild("a");
    auto bNode = root.createChild("b");
    auto cNode = root.createChild("c");

    auto a2Node = bNode.createChild("a");
    auto b2Node = cNode.createChild("b");

    auto a3Node = a2Node.createChild("a");

    assert(root.find("a").map!"a.name".equal(["a", "a", "a"]));
    assert(root.find("b").map!"a.name".equal(["b", "b"]));
    assert(root.find("c", false).map!"a.name".equal(["c"]));
}